{
  "history": [
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 0.25,
      "layerType": "effect",
      "type": "gradient",
      "usesPingPong": false,
      "speed": 0.25,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) { switch(index) { case 0: return vec3(0, 0, 0); case 1: return vec3(0, 0, 0); case 2: return vec3(0, 0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0, 0); }void main() {fragColor = vec4(0,0,0,0); return;vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); uv -= pos; uv /= (0.5000*2.); uv = rotate(uv, (0.0000 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 0.0000); fragColor = color; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"
      ],
      "data": {
        "downSample": 0.5,
        "depth": false,
        "uniforms": {},
        "isBackground": true
      },
      "id": "effect"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "beam",
      "usesPingPong": false,
      "speed": 0.25,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; precision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawPoint(vec2 uv, vec2 center, float scale) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(1.0000, 1. - 1.0000) * 2.; uv = uv * rot(0.0000 * TWO_PI) * skew; center = center * rot(0.0000 * TWO_PI) * skew; float dist = distance(uv, center); float radius = scale * 0.25;float brightness = radius / dist; brightness = mix(brightness, brightness*brightness, 0.0100); return brightness * vec3(0.20784313725490197, 0.2823529411764706, 0); }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); return drawPoint(uv, pos, 0.1000); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 1.0000); result += dither;vec4 color = vec4(result, max(bg.a, luma(beam))); fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect1"
    },
    {
      "breakpoints": [
        {
          "max": null,
          "name": "Desktop",
          "min": 992,
          "props": { "trackAxes": "y" }
        },
        {
          "min": 0,
          "name": "Mobile",
          "max": 575,
          "props": { "trackAxes": "y" }
        }
      ],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "beam",
      "usesPingPong": false,
      "speed": 0.25,
      "trackMouse": 1,
      "trackAxes": "y",
      "mouseMomentum": 0,
      "texture": false,
      "animating": true,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; precision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return 1. - (1. - src) * (1. - dst); }uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawPoint(vec2 uv, vec2 center, float scale) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.1800, 1. - 0.1800) * 2.; uv = uv * rot(0.2500 * TWO_PI) * skew; center = center * rot(0.2500 * TWO_PI) * skew; float dist = distance(uv, center); float radius = scale * 0.25;float brightness = radius / dist; brightness = mix(brightness, brightness*brightness, 1.0000); return brightness * vec3(0.5686274509803921, 0.7607843137254902, 0); }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 1.0000); return drawPoint(uv, pos, 0.0500); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(4, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 1.0000); result += dither;vec4 color = vec4(result, max(bg.a, luma(beam))); fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect2"
    },
    {
      "breakpoints": [
        {
          "props": { "left": 0.5, "top": 0.5 },
          "max": null,
          "min": 992,
          "name": "Desktop"
        },
        {
          "min": 0,
          "props": { "top": 0.5, "left": 0.5 },
          "name": "Mobile",
          "max": 575
        }
      ],
      "visible": true,
      "locked": false,
      "aspectRatio": 1.6017797552836486,
      "layerName": "Texture Image",
      "userDownsample": 1,
      "isElement": true,
      "opacity": 1,
      "effects": [
        "a7ba54de-573d-41fb-9026-e1389c63c85c",
        "468998e2-89a2-4a1c-90bc-465c4b2a7c3b"
      ],
      "displace": 0,
      "trackMouse": 0,
      "anchorPoint": "center",
      "mouseMomentum": 0,
      "blendMode": "COLOR_DODGE",
      "bgDisplace": 0,
      "mask": 0,
      "maskBackground": { "type": "Vec3", "_x": 0, "_y": 0, "_z": 0 },
      "maskAlpha": 0,
      "maskDepth": 0,
      "dispersion": 0,
      "axisTilt": 0,
      "states": { "appear": [], "scroll": [], "hover": [] },
      "layerType": "image",
      "imageLoaded": false,
      "width": 0.639,
      "widthMode": "relative",
      "height": 1.9038151041666667,
      "heightMode": "relative",
      "left": 0.5,
      "leftMode": "relative",
      "top": 0.5,
      "topMode": "relative",
      "rotation": 0,
      "trackAxes": "xy",
      "fitToCanvas": 0,
      "exposure": 0,
      "saturation": 1,
      "contrast": 1,
      "src": "https://firebasestorage.googleapis.com/v0/b/unicorn-studio.appspot.com/o/Zz28X5RDkvcGGVYLr9X6QdTIhxy1%2FUntitled%20design%20-%202025-10-14T141250.707.webp?alt=media&token=bfcd11a8-6529-41a6-a592-d78147e93840",
      "naturalWidth": 1440,
      "naturalHeight": 899,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform vec2 uMousePos; uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform int uSampleBg;vec3 blend (int blendMode, vec3 src, vec3 dst) { return vec3((src.x == 1.0) ? 1.0 : min(1.0, dst.x / (1.0 - src.x)), (src.y == 1.0) ? 1.0 : min(1.0, dst.y / (1.0 - src.y)), (src.z == 1.0) ? 1.0 : min(1.0, dst.z / (1.0 - src.z))); }const float STEPS = 24.0; const float PI = 3.1415926;out vec4 fragColor;vec4 getNormalOutput(vec4 color, vec4 background) { vec3 unpremultColor = color.rgb / max(color.a, 0.0001); vec3 blendedColor = blend(8, unpremultColor, background.rgb); color = vec4(blendedColor, 1.0) * (color.a * 1.0000); color = color + background * (1.0 - color.a); return color; }vec4 getOutputByMode(vec4 color, vec4 background) { return getNormalOutput(color, background); }void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv -= pos;vec4 background = vec4(0); if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); } vec4 color = texture(uTexture, uv);color.rgb = clamp(color.rgb, 0.0, 1.0) * color.a;vec4 col = getOutputByMode(color, background);fragColor = col; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision highp float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "uniforms": {} },
      "id": "image"
    },
    {
      "breakpoints": [
        {
          "min": 992,
          "name": "Desktop",
          "max": null,
          "props": { "trackAxes": "xy" }
        },
        {
          "max": 575,
          "min": 0,
          "name": "Mobile",
          "props": { "trackAxes": "y" }
        }
      ],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "projection",
      "usesPingPong": false,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "parentLayer": "468998e2-89a2-4a1c-90bc-465c4b2a7c3b",
      "animating": true,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime;uniform vec2 uMousePos;const float PI = 3.14159265;vec3 getRayDirection(vec2 uv, vec2 mousePos, float aspect) { vec2 screenPos = (uv - 0.5) * 2.0; screenPos.x *= aspect; screenPos.y *= -1.0; float minFOV = radians(20.0); float maxFOV = radians(120.0); float fov = mix(minFOV, maxFOV, 0.9000); vec3 rayDir = normalize(vec3(screenPos.x * tan(fov/2.0), screenPos.y * tan(fov/2.0), -1.0)); float rotX = (mousePos.y - 0.5) * PI; float rotY = (mousePos.x - 0.5) * PI * 2.0; mat3 rotateY = mat3( cos(rotY), 0.0, -sin(rotY), 0.0, 1.0, 0.0, sin(rotY), 0.0, cos(rotY) ); mat3 rotateX = mat3( 1.0, 0.0, 0.0, 0.0, cos(rotX), sin(rotX), 0.0, -sin(rotX), cos(rotX) ); return normalize(rotateX * rotateY * rayDir); }vec2 directionToUVHorizontal(vec3 dir) { float longitude = atan(dir.z, dir.x); float latitude = acos(dir.y); vec2 uv; uv.x = longitude / (2.0 * PI) + 0.5; uv.y = latitude / PI; uv.x += 0.25; return uv; }vec2 directionToUVVertical(vec3 dir) { float longitude = atan(dir.z, dir.y); float latitude = acos(dir.x); vec2 uv; uv.y = longitude / PI * -1.; uv.x = (latitude / (2.0 * PI) + 0.5) * -1.; uv.x = fract(uv.x + 0.25); return uv; }out vec4 fragColor;vec4 getRepeatVerticalUV(vec2 uv) { vec2 finalUV = vec2(uv.x, fract(uv.y)); vec4 col = texture(uTexture, finalUV); if (0.4100 > 0.0) { float blendWidth = 0.4100 * 0.1; float blendFactor = 0.0; if (finalUV.y < blendWidth) { blendFactor = 1.0 - (finalUV.y / blendWidth); } else if (finalUV.y > 1.0 - blendWidth) { blendFactor = (finalUV.y - (1.0 - blendWidth)) / blendWidth; } if (blendFactor > 0.0) { blendFactor = smoothstep(0.0, 1.0, blendFactor); vec2 oppositeUV = vec2(finalUV.x, finalUV.y > 0.5 ? finalUV.y - 0.5 : finalUV.y + 0.5); vec4 oppositeCol = texture(uTexture, oppositeUV); col = mix(col, oppositeCol, blendFactor); } } return col; }vec4 getRepeatUV(vec2 uv) { return getRepeatVerticalUV(uv); }void main() { float aspect = 2.; vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000 * 0.5); vec3 rayDir = getRayDirection(vTextureCoord, mPos, aspect); vec2 uvHorizontal = directionToUVHorizontal(rayDir); vec2 uvVertical = directionToUVVertical(rayDir); vec2 sphereUV = mix(uvHorizontal, uvVertical, 0.0000); float minFOV = radians(20.0); float maxFOV = radians(120.0); float currentFOV = mix(minFOV, maxFOV, 0.9000); float fovCompensation = tan(currentFOV/2.0); float compensatedScale = (mix(-0.1, 0.4, 0.2800) * 12.0 + 2.0) * (1.0/fovCompensation); sphereUV = (sphereUV - 0.5) * compensatedScale + 0.5;sphereUV += vec2(0, 0.4) * uTime * 0.005;vec4 col = getRepeatUV(sphereUV); fragColor = col;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect3"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "noiseFill",
      "usesPingPong": false,
      "speed": 0.25,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "parentLayer": "a7ba54de-573d-41fb-9026-e1389c63c85c",
      "animating": true,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution;vec3 hash33(vec3 p3) { p3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787)); p3 += dot(p3, p3.yxz + 19.19); return -1.0 + 2.0 * fract(vec3( (p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x )); }float perlin_noise(vec3 p) { vec3 pi = floor(p); vec3 pf = p - pi;vec3 w = pf * pf * (3.0 - 2.0 * pf);float n000 = dot(pf - vec3(0.0, 0.0, 0.0), hash33(pi + vec3(0.0, 0.0, 0.0))); float n100 = dot(pf - vec3(1.0, 0.0, 0.0), hash33(pi + vec3(1.0, 0.0, 0.0))); float n010 = dot(pf - vec3(0.0, 1.0, 0.0), hash33(pi + vec3(0.0, 1.0, 0.0))); float n110 = dot(pf - vec3(1.0, 1.0, 0.0), hash33(pi + vec3(1.0, 1.0, 0.0))); float n001 = dot(pf - vec3(0.0, 0.0, 1.0), hash33(pi + vec3(0.0, 0.0, 1.0))); float n101 = dot(pf - vec3(1.0, 0.0, 1.0), hash33(pi + vec3(1.0, 0.0, 1.0))); float n011 = dot(pf - vec3(0.0, 1.0, 1.0), hash33(pi + vec3(0.0, 1.0, 1.0))); float n111 = dot(pf - vec3(1.0, 1.0, 1.0), hash33(pi + vec3(1.0, 1.0, 1.0)));float nx00 = mix(n000, n100, w.x); float nx01 = mix(n001, n101, w.x); float nx10 = mix(n010, n110, w.x); float nx11 = mix(n011, n111, w.x);float nxy0 = mix(nx00, nx10, w.y); float nxy1 = mix(nx01, nx11, w.y);float nxyz = mix(nxy0, nxy1, w.z);return nxyz; }vec3 blend (int blendMode, vec3 src, vec3 dst) { return (src + dst) - 1.0; } uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }out vec4 fragColor;const float PI = 3.14159265359; const float TAU = 6.28318530718;vec3 anchoredPal(float t, vec3 col1, vec3 col2) { vec3 mid = 0.5 * (col1 + col2); vec3 axisAmp = 0.5 * (col2 - col1);vec3 base = mid + axisAmp * cos(TAU * t);vec3 axis = length(axisAmp) > 0.0001 ? normalize(axisAmp) : vec3(1.0, 0.0, 0.0); vec3 ref = abs(axis.x) > 0.9 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0); vec3 tangent1 = normalize(cross(axis, ref)); vec3 tangent2 = normalize(cross(axis, tangent1));float richness = 0.24 * length(axisAmp) + 0.02; vec3 ripple = tangent1 * sin(TAU * (t * 2.0 + 0.123)) + tangent2 * sin(TAU * (t * 3.0 + 0.437));vec3 col = base + (richness * 0.5000) * ripple; col = 1./(1. + exp(-col * 4. + 0.25) * 7.5); return col; }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }float getPerlinNoise(vec2 uv) { float turb = 0.6700 * 3.2; vec2 skew = vec2(0.9600, 1. - 0.9600); vec2 drift = vec2(0, -0.1300 * uTime * 0.0125) * mix(1., 14., 15.0000); float noise = perlin_noise(vec3( uv * skew - drift, 0.0000 + uTime * 0.03 ));return mix(0.5, noise * 0.5 + 0.5, turb); }float getNoise(vec2 uv) { return getPerlinNoise(uv); }void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y; vec2 aspect = vec2(aspectRatio, 1.0);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);vec2 pos = mix(vec2(0.5, 0.5), mPos, 0.0000); float scale = mix(1., 14., 15.0000); vec2 drift = vec2(0, -0.1300 * uTime * 0.0125); mat2 rotation = rot(0.0000 * 2. * PI);vec2 st = (uv - pos) * aspect * scale * rotation; float noise = getNoise(st);if (0.0000 > 0.0) { vec2 toMouse = (uv - uMousePos) * aspect; float r = length(toMouse); float radius = mix(0.1, 1., 0.5000); float falloff = 1.0 - smoothstep(0.0, radius, r); vec2 dir = toMouse / max(r, 1e-5); vec2 uvBulgeOffsetAspect = -dir * (0.0000 * radius) * falloff * falloff; vec2 offset = uvBulgeOffsetAspect / aspect * r * 5.;st = (uv - pos + offset * noise) * aspect * scale * rotation; noise = getNoise(st); }vec4 color = texture(uTexture, uv); vec4 bg = color; float shift = 0.0000 + (0.0000 * uTime * 0.01); vec3 noiseColor = anchoredPal(noise + shift, vec3(1, 1, 1), vec3(0, 0, 0)); color.rgb = noiseColor.rgb;float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither * 0.5;color.rgb = blend(10, bg.rgb, color.rgb);color.rgb = mix(bg.rgb, color.rgb, 1.0000); color.a = max(bg.a, 1.0000); fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect4"
    }
  ],
  "options": {
    "name": "Huly Laser",
    "fps": 60,
    "dpi": 1.5,
    "scale": 1,
    "includeLogo": false,
    "isProduction": false
  },
  "version": "1.4.35",
  "id": "GhXLKq38MVJsT4hPKmIj"
}
